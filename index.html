<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabla de Posiciones Fútbol 5</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Fuente Inter para una mejor legibilidad */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Un gris claro para el fondo */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-4xl">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Tabla de Posiciones</h1>

        <!-- Controles de Filtro -->
        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <div>
                <label for="year-select" class="block text-sm font-medium text-gray-700">Año:</label>
                <select id="year-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <!-- Opciones de año se generarán dinámicamente -->
                </select>
            </div>
            <div>
                <label for="period-select" class="block text-sm font-medium text-gray-700">Período:</label>
                <select id="period-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="totales">Totales</option>
                    <option value="apertura">Apertura</option>
                    <option value="clausura">Clausura</option>
                </select>
            </div>
            <div>
                <label for="criterion-select" class="block text-sm font-medium text-gray-700">Criterio:</label>
                <select id="criterion-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="puntos">Puntos</option>
                    <option value="chamigos">Chamigos Ganados</option>
                    <option value="tt">Asistencias TT</option>
                </select>
            </div>
        </div>

        <div id="leaderboard-container" class="overflow-x-auto">
            <p id="loading-message" class="text-gray-500 text-center">Cargando tabla de posiciones...</p>
            <table id="leaderboard-table" class="min-w-full bg-white rounded-lg shadow hidden">
                <thead>
                    <tr class="bg-gray-200 text-gray-700 uppercase text-sm leading-normal">
                        <th class="py-3 px-6 text-left">Posición</th>
                        <th class="py-3 px-6 text-left">Jugador</th>
                        <th class="py-3 px-6 text-center">Puntos</th>
                        <th class="py-3 px-6 text-center">Partidos</th>
                        <th class="py-3 px-6 text-center">Chamigos</th>
                        <th class="py-3 px-6 text-center">TT</th>
                    </tr>
                </thead>
                <tbody class="text-gray-600 text-sm font-light">
                    <!-- Filas de jugadores se cargarán aquí -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Script de la API de Google -->
    <script async src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>

    <script>
        // ¡IMPORTANTE! Reemplaza 'TU_ID_DE_HOJA_DE_CALCULO' con el ID de tu Google Sheet "Base de Datos".
        const SPREADSHEET_ID = '1bpNKl-UVHzbqsow4zOHE7-y5Cunm2xtpgyIodEQBi2E'; // Asegúrate de que este sea tu ID real
        // La API Key es necesaria para llamadas públicas sin autenticación de usuario.
        // Asegúrate de que la API Key esté restringida a la API de Google Sheets y a tu dominio de GitHub Pages.
        const API_KEY = 'AIzaSyDNLwReGrX5FKBwjjKsMS9cz-hZNMIvAlM'; // ¡Necesitas una API Key válida aquí!

        let gapiInited = false;
        let allPlayersData = []; // Para almacenar todos los datos de jugadores una vez
        let allMatchesData = []; // Para almacenar todos los datos de partidos una vez

        const loadingMessage = document.getElementById('loading-message');
        const leaderboardTable = document.getElementById('leaderboard-table');
        const leaderboardTableBody = leaderboardTable.querySelector('tbody');
        const yearSelect = document.getElementById('year-select');
        const periodSelect = document.getElementById('period-select');
        const criterionSelect = document.getElementById('criterion-select');

        // Función para parsear fechas DD/MM/YYYY a objetos Date
        function parseDate(dateString) {
            const [day, month, year] = dateString.split('/').map(Number);
            return new Date(year, month - 1, day); // month - 1 porque los meses en Date son 0-indexados
        }

        // Función que se ejecuta cuando la librería gapi (API de Google) está cargada
        // Esta función ahora es llamada directamente por el atributo 'onload' del script tag
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        // Inicializa el cliente de la API de Google
        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                });
                gapiInited = true;
                await loadAllDataAndRenderLeaderboard(); // Carga todos los datos y renderiza
            } catch (err) {
                console.error('Error al inicializar cliente GAPI:', err);
                loadingMessage.textContent = `Error al cargar la tabla: ${err.message}. Asegúrate de que la API Key sea válida y la hoja esté compartida públicamente como "Lector".`;
                loadingMessage.classList.remove('hidden');
                leaderboardTable.classList.add('hidden');
            }
        }

        /**
         * Carga todos los datos de jugadores y partidos de Google Sheets.
         */
        async function loadAllDataAndRenderLeaderboard() {
            loadingMessage.textContent = 'Cargando datos...';
            loadingMessage.classList.remove('hidden');
            leaderboardTable.classList.add('hidden');

            try {
                // Cargar jugadores
                const playersResponse = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'Jugadores!A:G', // ID_Jugador, Nombre, Estado, Puntos_Totales, Partidos_Jugados, Chamigos_Ganados, TT_Asistencias
                });
                allPlayersData = playersResponse.result.values ? playersResponse.result.values.slice(1) : []; // Ignorar encabezados

                // Cargar partidos
                const matchesResponse = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'Partidos!A:G', // ID_Partido, Fecha, Equipo_Claros_IDs, Equipo_Oscuros_IDs, Resultado, Chamigo_Votos, Asistencia_TT_IDs
                });
                allMatchesData = matchesResponse.result.values ? matchesResponse.result.values.slice(1) : []; // Ignorar encabezados

                populateYearSelect(); // Rellenar el selector de año
                renderLeaderboard(); // Renderizar la tabla inicial
            } catch (err) {
                console.error('Error al cargar todos los datos:', err);
                // Mejorar el mensaje de error para el usuario en la interfaz
                let userErrorMessage = 'Error desconocido al cargar datos.';
                if (err && err.result && err.result.error && err.result.error.message) {
                    userErrorMessage = `Error al cargar datos: ${err.result.error.message}. Verifica la configuración de tu hoja de cálculo y API Key.`;
                } else if (err && err.message) {
                    userErrorMessage = `Error al cargar datos: ${err.message}. Verifica la configuración de tu hoja de cálculo y API Key.`;
                }
                loadingMessage.textContent = userErrorMessage;
                loadingMessage.classList.remove('hidden');
                leaderboardTable.classList.add('hidden');
            }
        }

        /**
         * Rellena el selector de año con los años disponibles en los partidos.
         */
        function populateYearSelect() {
            const years = new Set();
            allMatchesData.forEach(match => {
                const dateString = match[1]; // Columna 'Fecha'
                if (dateString) {
                    const date = parseDate(dateString);
                    years.add(date.getFullYear());
                }
            });

            const sortedYears = Array.from(years).sort((a, b) => b - a); // Ordenar de más reciente a más antiguo

            yearSelect.innerHTML = ''; // Limpiar opciones existentes
            if (sortedYears.length > 0) {
                sortedYears.forEach(year => {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    yearSelect.appendChild(option);
                });
                // Seleccionar el año actual por defecto si existe, o el más reciente
                const currentYear = new Date().getFullYear();
                if (sortedYears.includes(currentYear)) {
                    yearSelect.value = currentYear;
                } else {
                    yearSelect.value = sortedYears[0];
                }
            } else {
                const option = document.createElement('option');
                option.value = new Date().getFullYear(); // Año actual si no hay datos
                option.textContent = new Date().getFullYear();
                yearSelect.appendChild(option);
            }
        }

        /**
         * Filtra los partidos según el año y el período seleccionados.
         */
        function filterMatches(matches, selectedYear, selectedPeriod) {
            return matches.filter(match => {
                const dateString = match[1]; // Columna 'Fecha'
                if (!dateString) return false;

                const matchDate = parseDate(dateString);
                const matchYear = matchDate.getFullYear();
                const matchMonth = matchDate.getMonth(); // 0-indexed

                if (selectedYear !== 'all' && matchYear !== parseInt(selectedYear)) {
                    return false;
                }

                if (selectedPeriod === 'apertura') {
                    return matchMonth >= 0 && matchMonth <= 5; // Enero (0) a Junio (5)
                } else if (selectedPeriod === 'clausura') {
                    return matchMonth >= 6 && matchMonth <= 11; // Julio (6) a Diciembre (11)
                }
                return true; // "totales" o si no hay período seleccionado
            });
        }

        /**
         * Calcula las estadísticas de los jugadores basándose en los partidos filtrados.
         */
        function calculatePlayerStats(players, filteredMatches) {
            const playerStats = {};

            // Inicializar estadísticas para todos los jugadores activos
            players.forEach(player => {
                const [id, nombre, estado] = player;
                if (estado === 'Activo') {
                    playerStats[id] = {
                        id,
                        nombre,
                        puntos: 0,
                        partidos: 0,
                        chamigos: 0,
                        tt: 0
                    };
                }
            });

            filteredMatches.forEach(match => {
                const [idPartido, fecha, equipoClarosIDsStr, equipoOscurosIDsStr, resultado, chamigoVotosStr, asistenciaTTIDsStr] = match;

                const equipoClarosIDs = equipoClarosIDsStr ? equipoClarosIDsStr.split(',') : [];
                const equipoOscurosIDs = equipoOscurosIDsStr ? equipoOscurosIDsStr.split(',') : [];
                const allPlayersInMatch = new Set([...equipoClarosIDs, ...equipoOscurosIDs]);

                // Contar partidos jugados
                allPlayersInMatch.forEach(playerId => {
                    if (playerStats[playerId]) {
                        playerStats[playerId].partidos++;
                    }
                });

                // Asignar puntos por resultado
                if (resultado === 'Claros' || resultado === 'Oscuros') {
                    const winningTeam = resultado === 'Claros' ? equipoClarosIDs : equipoOscurosIDs;
                    const losingTeam = resultado === 'Claros' ? equipoOscurosIDs : equipoClarosIDs;

                    winningTeam.forEach(playerId => {
                        if (playerStats[playerId]) playerStats[playerId].puntos += 3;
                    });
                    losingTeam.forEach(playerId => {
                        // Los perdedores no suman puntos
                    });
                } else if (resultado === 'Empate') {
                    allPlayersInMatch.forEach(playerId => {
                        if (playerStats[playerId]) playerStats[playerId].puntos += 1;
                    });
                }

                // Contar Chamigos
                if (chamigoVotosStr) {
                    try {
                        const chamigoVotos = JSON.parse(chamigoVotosStr);
                        // Encontrar el/los chamigo(s) con más votos para este partido
                        if (chamigoVotos.length > 0) {
                            const maxVotes = Math.max(...chamigoVotos.map(v => v.votos));
                            const chamigosDelPartido = chamigoVotos.filter(v => v.votos === maxVotes);
                            chamigosDelPartido.forEach(chamigo => {
                                if (playerStats[chamigo.id]) playerStats[chamigo.id].chamigos++;
                            });
                        }
                    } catch (e) {
                        console.warn('Error al parsear votos de chamigo:', chamigoVotosStr, e);
                    }
                }

                // Contar asistencias a TT
                if (asistenciaTTIDsStr) {
                    const ttAttendees = asistenciaTTIDsStr.split(',');
                    ttAttendees.forEach(playerId => {
                        if (playerStats[playerId]) playerStats[playerId].tt++;
                    });
                }
            });

            return Object.values(playerStats); // Convertir a array de objetos
        }

        /**
         * Renderiza la tabla de posiciones con los datos filtrados y ordenados.
         */
        function renderLeaderboard() {
            loadingMessage.textContent = 'Calculando posiciones...';
            loadingMessage.classList.remove('hidden');
            leaderboardTable.classList.add('hidden');
            leaderboardTableBody.innerHTML = ''; // Limpiar tabla

            const selectedYear = yearSelect.value;
            const selectedPeriod = periodSelect.value;
            const selectedCriterion = criterionSelect.value;

            // 1. Filtrar partidos
            const filteredMatches = filterMatches(allMatchesData, selectedYear, selectedPeriod);

            // 2. Calcular estadísticas de jugadores
            let playersWithStats = calculatePlayerStats(allPlayersData, filteredMatches);

            // 3. Ordenar jugadores
            playersWithStats.sort((a, b) => {
                if (selectedCriterion === 'puntos') {
                    return b.puntos - a.puntos;
                } else if (selectedCriterion === 'chamigos') {
                    return b.chamigos - a.chamigos;
                } else if (selectedCriterion === 'tt') {
                    return b.tt - a.tt;
                }
                return 0; // Por defecto no ordena si el criterio no es reconocido
            });

            // Filtrar jugadores con 0 partidos jugados si el criterio es puntos, chamigos o tt
            if (selectedCriterion === 'puntos' || selectedCriterion === 'chamigos' || selectedCriterion === 'tt') {
                playersWithStats = playersWithStats.filter(player => player.partidos > 0);
            }


            if (playersWithStats.length > 0) {
                playersWithStats.forEach((player, index) => {
                    const row = `
                        <tr class="border-b border-gray-200 hover:bg-gray-100">
                            <td class="py-3 px-6 text-left whitespace-nowrap font-medium">${index + 1}</td>
                            <td class="py-3 px-6 text-left">${player.nombre}</td>
                            <td class="py-3 px-6 text-center">${player.puntos}</td>
                            <td class="py-3 px-6 text-center">${player.partidos}</td>
                            <td class="py-3 px-6 text-center">${player.chamigos}</td>
                            <td class="py-3 px-6 text-center">${player.tt}</td>
                        </tr>
                    `;
                    leaderboardTableBody.innerHTML += row;
                });
                loadingMessage.classList.add('hidden');
                leaderboardTable.classList.remove('hidden');
            } else {
                loadingMessage.textContent = 'No hay datos disponibles para los filtros seleccionados.';
                loadingMessage.classList.remove('hidden');
                leaderboardTable.classList.add('hidden');
            }
        }

        // Event Listeners para los selectores
        yearSelect.addEventListener('change', renderLeaderboard);
        periodSelect.addEventListener('change', renderLeaderboard);
        criterionSelect.addEventListener('change', renderLeaderboard);

        // Carga la librería de Google API cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Tabla de Posiciones de Fútbol 5 cargada!');
            // La función gapiLoaded() ahora se llama a través del atributo 'onload' del script tag de la API de Google.
            // Esto asegura que 'gapi' esté definido cuando se intente usar.
        });
    </script>
</body>
</html>
