<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tabla de Posiciones Fútbol 5</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Fuente Inter para una mejor legibilidad */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Un gris claro para el fondo */
        }
        /* Estilos base para tablas */
        table {
            @apply min-w-full bg-white rounded-lg shadow-md;
        }
        th, td {
            @apply py-3 px-6 text-left;
        }
        /* Encabezado de la tabla: fondo negro, texto blanco */
        thead th {
            @apply bg-gray-900 text-white uppercase text-sm leading-normal;
        }
        /* Filas del cuerpo de la tabla: alternar entre dos tonos de gris */
        tbody tr:nth-child(odd) {
            @apply bg-gray-100; /* Tono de gris más claro para filas impares */
        }
        tbody tr:nth-child(even) {
            @apply bg-gray-200; /* Tono de gris más oscuro para filas pares */
        }
        tbody tr {
            @apply border-b border-gray-300 hover:bg-gray-300 transition duration-150 ease-in-out;
        }
        tbody tr:last-child {
            @apply border-b-0;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-4xl">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Tabla de Posiciones</h1>

        <!-- Controles de Filtro Mejorados -->
        <div class="flex flex-wrap justify-center gap-4 mb-8 p-4 bg-gray-50 rounded-lg shadow-inner">
            <div class="flex flex-col items-start w-full sm:w-auto flex-grow">
                <label for="year-select" class="block text-sm font-medium text-gray-700 mb-1">Año:</label>
                <select id="year-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 bg-white">
                    <!-- Opciones de año se generarán dinámicamente -->
                </select>
            </div>
            <div class="flex flex-col items-start w-full sm:w-auto flex-grow">
                <label for="period-select" class="block text-sm font-medium text-gray-700 mb-1">Período:</label>
                <select id="period-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 bg-white">
                    <option value="totales">Totales</option>
                    <option value="apertura">Apertura</option>
                    <option value="clausura">Clausura</option>
                </select>
            </div>
            <div class="flex flex-col items-start w-full sm:w-auto flex-grow">
                <label for="criterion-select" class="block text-sm font-medium text-gray-700 mb-1">Criterio:</label>
                <select id="criterion-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 bg-white">
                    <option value="puntos">Puntos</option>
                    <option value="presentismo">Presentismo</option>
                    <option value="ausentismo">Ausentismo</option>
                    <option value="chamigos">Chamigo</option>
                    <option value="tt">TT</option>
                </select>
            </div>
        </div>

        <div id="leaderboard-container" class="overflow-x-auto">
            <p id="loading-message" class="text-gray-500 text-center">Cargando tabla de posiciones...</p>
            <table id="leaderboard-table" class="min-w-full bg-white rounded-lg shadow hidden">
                <thead>
                    <!-- Los encabezados se generarán dinámicamente según el criterio -->
                </thead>
                <tbody class="text-gray-600 text-sm font-light">
                    <!-- Filas de jugadores se cargarán aquí -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // ¡IMPORTANTE! Reemplaza 'TU_ID_DE_HOJA_DE_CALCULO' con el ID de tu Google Sheet "Base de Datos".
        const SPREADSHEET_ID = '1bpNKl-UVHzbqsow4zOHE7-y5Cunm2xtpgyIodEQBi2E'; // Asegúrate de que este sea tu ID real
        // La API Key es necesaria para llamadas públicas sin autenticación de usuario.
        // Asegúrate de que la API Key esté restringida a la API de Google Sheets y a tu dominio de GitHub Pages.
        const API_KEY = 'AIzaSyDNLwReGrX5FKBwjjKsMS9cz-hZNMIvAlM'; // ¡Tu API Key real!

        let gapiInited = false;
        let allPlayersData = []; // Para almacenar todos los datos de jugadores una vez
        let allMatchesData = []; // Para almacenar todos los datos de partidos una vez

        const loadingMessage = document.getElementById('loading-message');
        const leaderboardTable = document.getElementById('leaderboard-table');
        const leaderboardTableHead = leaderboardTable.querySelector('thead'); // Referencia al thead
        const leaderboardTableBody = leaderboardTable.querySelector('tbody');
        const yearSelect = document.getElementById('year-select');
        const periodSelect = document.getElementById('period-select');
        const criterionSelect = document.getElementById('criterion-select');

        // Función para parsear fechas DD/MM/YYYY a objetos Date
        function parseDate(dateString) {
            const [day, month, year] = dateString.split('/').map(Number);
            return new Date(year, month - 1, day); // month - 1 porque los meses en Date son 0-indexados
        }

        // Función que se ejecuta cuando la librería gapi (API de Google) está cargada
        // ¡IMPORTANTE! Esta función debe estar definida ANTES del script de la API de Google.
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        // Inicializa el cliente de la API de Google
        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                });
                gapiInited = true;
                await loadAllDataAndRenderLeaderboard(); // Carga todos los datos y renderiza
            } catch (err) {
                console.error('Error al inicializar cliente GAPI:', err);
                loadingMessage.textContent = `Error al cargar la tabla: ${err.message}. Asegúrate de que la API Key sea válida y la hoja esté compartida públicamente como "Lector".`;
                loadingMessage.classList.remove('hidden');
                leaderboardTable.classList.add('hidden');
            }
        }

        /**
         * Carga todos los datos de jugadores y partidos de Google Sheets.
         */
        async function loadAllDataAndRenderLeaderboard() {
            loadingMessage.textContent = 'Cargando datos...';
            loadingMessage.classList.remove('hidden');
            leaderboardTable.classList.add('hidden');

            try {
                // Cargar jugadores
                const playersResponse = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'Jugadores!A:G', // ID_Jugador, Nombre, Estado, Puntos_Totales, Partidos_Jugados, Chamigos_Ganados, TT_Asistencias
                });
                allPlayersData = playersResponse.result.values ? playersResponse.result.values.slice(1) : []; // Ignorar encabezados

                // Cargar partidos
                const matchesResponse = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: SPREADSHEET_ID,
                    range: 'Partidos!A:G', // ID_Partido, Fecha, Equipo_Claros_IDs, Equipo_Oscuros_IDs, Resultado, Chamigo_Votos, Asistencia_TT_IDs
                });
                allMatchesData = matchesResponse.result.values ? matchesResponse.result.values.slice(1) : []; // Ignorar encabezados

                populateYearSelect(); // Rellenar el selector de año
                setInitialPeriod(); // Establecer el período inicial
                renderLeaderboard(); // Renderizar la tabla inicial
            } catch (err) {
                console.error('Error al cargar todos los datos:', err);
                // Mejorar el mensaje de error para el usuario en la interfaz
                let userErrorMessage = 'Error desconocido al cargar datos.';
                if (err && err.result && err.result.error && err.result.error.message) {
                    userErrorMessage = `Error al cargar datos: ${err.result.error.message}. Verifica la configuración de tu hoja de cálculo y API Key.`;
                } else if (err && err.message) {
                    userErrorMessage = `Error al cargar datos: ${err.message}. Verifica la configuración de tu hoja de cálculo y API Key.`;
                }
                loadingMessage.textContent = userErrorMessage;
                loadingMessage.classList.remove('hidden');
                leaderboardTable.classList.add('hidden');
            }
        }

        /**
         * Rellena el selector de año con los años disponibles en los partidos.
         * Selecciona el año actual por defecto si existe, o el más reciente.
         */
        function populateYearSelect() {
            const years = new Set();
            allMatchesData.forEach(match => {
                const dateString = match[1]; // Columna 'Fecha'
                if (dateString) {
                    const date = parseDate(dateString);
                    years.add(date.getFullYear());
                }
            });

            const sortedYears = Array.from(years).sort((a, b) => b - a); // Ordenar de más reciente a más antiguo

            yearSelect.innerHTML = ''; // Limpiar opciones existentes
            if (sortedYears.length > 0) {
                sortedYears.forEach(year => {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    yearSelect.appendChild(option);
                });
                // Seleccionar el año actual por defecto si existe, o el más reciente
                const currentYear = new Date().getFullYear();
                if (sortedYears.includes(currentYear)) {
                    yearSelect.value = currentYear;
                } else {
                    yearSelect.value = sortedYears[0];
                }
            } else {
                const option = document.createElement('option');
                option.value = new Date().getFullYear(); // Año actual si no hay datos
                option.textContent = new Date().getFullYear();
                yearSelect.appendChild(option);
            }
        }

        /**
         * Establece el período inicial (Apertura/Clausura/Totales) basado en la fecha actual.
         */
        function setInitialPeriod() {
            const currentMonth = new Date().getMonth(); // 0-indexed (Enero es 0)
            if (currentMonth >= 0 && currentMonth <= 5) { // Enero a Junio
                periodSelect.value = 'apertura';
            } else if (currentMonth >= 6 && currentMonth <= 11) { // Julio a Diciembre
                periodSelect.value = 'clausura';
            } else {
                periodSelect.value = 'totales'; // Por defecto, si no cae en Apertura/Clausura
            }
        }

        /**
         * Filtra los partidos según el año y el período seleccionados.
         */
        function filterMatches(matches, selectedYear, selectedPeriod) {
            // Solo considerar partidos que tienen fecha y no están suspendidos
            const validMatches = matches.filter(match => match[1] && match[1].trim() !== '' && match[4] !== 'Suspendido');

            return validMatches.filter(match => {
                const dateString = match[1]; // Columna 'Fecha'
                const matchDate = parseDate(dateString);
                const matchYear = matchDate.getFullYear();
                const matchMonth = matchDate.getMonth(); // 0-indexed

                if (selectedYear !== 'all' && matchYear !== parseInt(selectedYear)) {
                    return false;
                }

                if (selectedPeriod === 'apertura') {
                    return matchMonth >= 0 && matchMonth <= 5; // Enero (0) a Junio (5)
                } else if (selectedPeriod === 'clausura') {
                    return matchMonth >= 6 && matchMonth <= 11; // Julio (6) a Diciembre (11)
                }
                return true; // "totales" o si no hay período seleccionado
            });
        }

        /**
         * Calcula las estadísticas de los jugadores basándose en los partidos filtrados.
         * Incluye cálculo de Efectividad y Ausente.
         */
        function calculatePlayerStats(players, filteredMatches) {
            const playerStats = {};
            const totalMatchesInPeriod = filteredMatches.length;

            // Inicializar estadísticas para todos los jugadores activos
            players.forEach(player => {
                const [id, nombre, estado] = player;
                if (estado === 'Activo') {
                    playerStats[id] = {
                        id,
                        nombre,
                        puntos: 0,
                        partidos: 0, // PJ
                        chamigos: 0, // Chamigo
                        tt: 0,
                        efectividad: '0.00%', // Nueva columna
                        ausente: totalMatchesInPeriod // Nueva columna, se ajustará
                    };
                }
            });

            filteredMatches.forEach(match => {
                const [idPartido, fecha, equipoClarosIDsStr, equipoOscurosIDsStr, resultado, chamigoVotosStr, asistenciaTTIDsStr] = match;

                const equipoClarosIDs = equipoClarosIDsStr ? equipoClarosIDsStr.split(',').filter(Boolean) : [];
                const equipoOscurosIDs = equipoOscurosIDsStr ? equipoOscurosIDsStr.split(',').filter(Boolean) : [];
                const allPlayersInMatch = new Set([...equipoClarosIDs, ...equipoOscurosIDs]);

                // Contar partidos jugados (PJ) y ajustar Ausente
                allPlayersInMatch.forEach(playerId => {
                    if (playerStats[playerId]) {
                        playerStats[playerId].partidos++;
                        playerStats[playerId].ausente--; // Restar 1 por cada partido jugado
                    }
                });

                // Asignar puntos por resultado
                if (resultado === 'Claros' || resultado === 'Oscuros') {
                    const winningTeam = resultado === 'Claros' ? equipoClarosIDs : equipoOscurosIDs;
                    winningTeam.forEach(playerId => {
                        if (playerStats[playerId]) playerStats[playerId].puntos += 3;
                    });
                } else if (resultado === 'Empate') {
                    allPlayersInMatch.forEach(playerId => {
                        if (playerStats[playerId]) playerStats[playerId].puntos += 1;
                    });
                }

                // Contar Chamigos
                if (chamigoVotosStr) {
                    try {
                        const chamigoVotos = JSON.parse(chamigoVotosStr);
                        if (chamigoVotos.length > 0) {
                            const maxVotes = Math.max(...chamigoVotos.map(v => v.votos));
                            const chamigosDelPartido = chamigoVotos.filter(v => v.votos === maxVotes);
                            chamigosDelPartido.forEach(chamigo => {
                                if (playerStats[chamigo.id]) playerStats[chamigo.id].chamigos++;
                            });
                        }
                    } catch (e) {
                        console.warn('Error al parsear votos de chamigo:', chamigoVotosStr, e);
                    }
                }

                // Contar asistencias a TT
                if (asistenciaTTIDsStr) {
                    const ttAttendees = asistenciaTTIDsStr.split(',').filter(Boolean);
                    ttAttendees.forEach(playerId => {
                        if (playerStats[playerId]) playerStats[playerId].tt++;
                    });
                }
            });

            // Calcular Efectividad después de contar todos los puntos y PJ
            Object.values(playerStats).forEach(player => {
                const maxPossiblePoints = player.partidos * 3;
                if (maxPossiblePoints > 0) {
                    player.efectividad = ((player.puntos / maxPossiblePoints) * 100).toFixed(2) + '%';
                } else {
                    player.efectividad = '0.00%';
                }
            });

            return Object.values(playerStats); // Convertir a array de objetos
        }

        /**
         * Renderiza la tabla de posiciones con los datos filtrados y ordenados,
         * adaptando las columnas según el criterio seleccionado.
         */
        function renderLeaderboard() {
            loadingMessage.textContent = 'Calculando posiciones...';
            loadingMessage.classList.remove('hidden');
            leaderboardTable.classList.add('hidden');
            leaderboardTableBody.innerHTML = ''; // Limpiar tabla

            const selectedYear = yearSelect.value;
            const selectedPeriod = periodSelect.value;
            const selectedCriterion = criterionSelect.value;

            // 1. Filtrar partidos
            const filteredMatches = filterMatches(allMatchesData, selectedYear, selectedPeriod);

            // 2. Calcular estadísticas de jugadores (incluye Efectividad y Ausente)
            let playersWithStats = calculatePlayerStats(allPlayersData, filteredMatches);

            // NO SE FILTRA POR players.partidos > 0 AQUÍ
            // La propuesta del usuario es mostrar a TODOS los jugadores activos,
            // incluso si no tienen partidos jugados, puntos, chamigos o TT.

            // 3. Ordenar jugadores
            playersWithStats.sort((a, b) => {
                if (selectedCriterion === 'puntos') {
                    return b.puntos - a.puntos;
                } else if (selectedCriterion === 'presentismo') {
                    return b.partidos - a.partidos; // Ordenar por PJ DESC
                } else if (selectedCriterion === 'ausentismo') {
                    return a.ausente - b.ausente; // Ordenar por Ausente DESC
                } else if (selectedCriterion === 'chamigos') {
                    return b.chamigos - a.chamigos;
                } else if (selectedCriterion === 'tt') {
                    return b.tt - a.tt;
                }
                return 0; // Por defecto no ordena si el criterio no es reconocido
            });

            // 4. Actualizar encabezados de la tabla (<thead>)
            let headerRowHTML = '';
            if (selectedCriterion === 'puntos') {
                headerRowHTML = `
                    <tr class="bg-gray-200 text-gray-700 uppercase text-sm leading-normal">
                        <th class="py-3 px-6 text-left">Posición</th>
                        <th class="py-3 px-6 text-left">Jugador</th>
                        <th class="py-3 px-6 text-center">Puntos</th>
                        <th class="py-3 px-6 text-center">PJ</th>
                        <th class="py-3 px-6 text-center">Efectividad</th>
                    </tr>
                `;
            } else if (selectedCriterion === 'presentismo') {
                headerRowHTML = `
                    <tr class="bg-gray-200 text-gray-700 uppercase text-sm leading-normal">
                        <th class="py-3 px-6 text-left">Posición</th>
                        <th class="py-3 px-6 text-left">Jugador</th>
                        <th class="py-3 px-6 text-center">PJ</th>
                    </tr>
                `;
            } else if (selectedCriterion === 'ausentismo') {
                headerRowHTML = `
                    <tr class="bg-gray-200 text-gray-700 uppercase text-sm leading-normal">
                        <th class="py-3 px-6 text-left">Posición</th>
                        <th class="py-3 px-6 text-left">Jugador</th>
                        <th class="py-3 px-6 text-center">Ausente</th>
                    </tr>
                `;
            } else if (selectedCriterion === 'chamigos') {
                headerRowHTML = `
                    <tr class="bg-gray-200 text-gray-700 uppercase text-sm leading-normal">
                        <th class="py-3 px-6 text-left">Posición</th>
                        <th class="py-3 px-6 text-left">Jugador</th>
                        <th class="py-3 px-6 text-center">Chamigo</th>
                    </tr>
                `;
            } else if (selectedCriterion === 'tt') {
                headerRowHTML = `
                    <tr class="bg-gray-200 text-gray-700 uppercase text-sm leading-normal">
                        <th class="py-3 px-6 text-left">Posición</th>
                        <th class="py-3 px-6 text-left">Jugador</th>
                        <th class="py-3 px-6 text-center">TT</th>
                    </tr>
                `;
            }
            leaderboardTableHead.innerHTML = headerRowHTML;

            // 5. Llenar el cuerpo de la tabla (<tbody>)
            if (playersWithStats.length > 0) {
                playersWithStats.forEach((player, index) => {
                    let rowHTML = '';
                    if (selectedCriterion === 'puntos') {
                        rowHTML = `
                            <td class="py-3 px-6 text-left whitespace-nowrap font-medium">${index + 1}</td>
                            <td class="py-3 px-6 text-left">${player.nombre}</td>
                            <td class="py-3 px-6 text-center">${player.puntos}</td>
                            <td class="py-3 px-6 text-center">${player.partidos}</td>
                            <td class="py-3 px-6 text-center">${player.efectividad}</td>
                        `;
                    } else if (selectedCriterion === 'presentismo') {
                        rowHTML = `
                            <td class="py-3 px-6 text-left whitespace-nowrap font-medium">${index + 1}</td>
                            <td class="py-3 px-6 text-left">${player.nombre}</td>
                            <td class="py-3 px-6 text-center">${player.partidos}</td>
                        `;
                    } else if (selectedCriterion === 'ausentismo') {
                        rowHTML = `
                            <td class="py-3 px-6 text-left whitespace-nowrap font-medium">${index + 1}</td>
                            <td class="py-3 px-6 text-left">${player.nombre}</td>
                            <td class="py-3 px-6 text-center">${player.ausente}</td>
                        `;
                    } else if (selectedCriterion === 'chamigos') {
                        rowHTML = `
                            <td class="py-3 px-6 text-left whitespace-nowrap font-medium">${index + 1}</td>
                            <td class="py-3 px-6 text-left">${player.nombre}</td>
                            <td class="py-3 px-6 text-center">${player.chamigos}</td>
                        `;
                    } else if (selectedCriterion === 'tt') {
                        rowHTML = `
                            <td class="py-3 px-6 text-left whitespace-nowrap font-medium">${index + 1}</td>
                            <td class="py-3 px-6 text-left">${player.nombre}</td>
                            <td class="py-3 px-6 text-center">${player.tt}</td>
                        `;
                    }
                    leaderboardTableBody.innerHTML += `<tr class="border-b border-gray-200 hover:bg-gray-100">${rowHTML}</tr>`;
                });
                loadingMessage.classList.add('hidden');
                leaderboardTable.classList.remove('hidden');
            } else {
                loadingMessage.textContent = 'No hay datos disponibles para los filtros seleccionados.';
                loadingMessage.classList.remove('hidden');
                leaderboardTable.classList.add('hidden');
            }
        }

        // Event Listeners para los selectores
        yearSelect.addEventListener('change', renderLeaderboard);
        periodSelect.addEventListener('change', renderLeaderboard);
        criterionSelect.addEventListener('change', renderLeaderboard);

        // Carga la librería de Google API cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Tabla de Posiciones de Fútbol 5 cargada!');
            // La función gapiLoaded() ahora se llama a través del atributo 'onload' del script tag de la API de Google.
            // Esto asegura que 'gapi' esté definido cuando se intente usar.
        });
    </script>
    <!-- Script de la API de Google -->
    <!-- Este script debe estar DESPUÉS de la definición de gapiLoaded() -->
    <script async src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
</body>
</html>
